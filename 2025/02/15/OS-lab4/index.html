<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>OS_lab4 | BETTER</title><meta name="author" content="LLUckkk"><meta name="copyright" content="LLUckkk"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Lab4 上机前复习Good luck to you~ 太久不上机，之前的技巧不要忘了：  grep -r 实现查找 tmux分屏，exit退出分屏 &amp;#x2F;str在vim界面下实现查找 减法压栈，加法弹栈（释放空间） envid2env(u_int envid, struct Env **pe"><link rel="shortcut icon" href="/img/tx.jpg"><link rel="canonical" href="https://lluckkk.github.io/2025/02/15/OS-lab4/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.14.0-b3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>(()=>{
      const saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
      
      window.btf = {
        saveToLocal: saveToLocal,
        getScript: (url, attr = {}) => new Promise((resolve, reject) => {
          const script = document.createElement('script')
          script.src = url
          script.async = true
          script.onerror = reject
          script.onload = script.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            script.onload = script.onreadystatechange = null
            resolve()
          }

          Object.keys(attr).forEach(key => {
            script.setAttribute(key, attr[key])
          })

          document.head.appendChild(script)
        }),

        getCSS: (url, id = false) => new Promise((resolve, reject) => {
          const link = document.createElement('link')
          link.rel = 'stylesheet'
          link.href = url
          if (id) link.id = id
          link.onerror = reject
          link.onload = link.onreadystatechange = function() {
            const loadState = this.readyState
            if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
            link.onload = link.onreadystatechange = null
            resolve()
          }
          document.head.appendChild(link)
        }),

        addGlobalFn: (key, fn, name = false, parent = window) => {
          const pjaxEnable = false
          if (!pjaxEnable && key.startsWith('pjax')) return

          const globalFn = parent.globalFn || {}
          const keyObj = globalFn[key] || {}
    
          if (name && keyObj[name]) return
    
          name = name || Object.keys(keyObj).length
          keyObj[name] = fn
          globalFn[key] = keyObj
          parent.globalFn = globalFn
        }
      }
    
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode
      
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'OS_lab4',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2025-02-15 17:18:30'
}</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    btf.addGlobalFn('pjaxSend', () => { preloader.initLoading() }, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', () => { preloader.endLoading() }, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="BETTER"><span class="site-name">BETTER</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">OS_lab4</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-02-15T09:16:49.000Z" title="Created 2025-02-15 17:16:49">2025-02-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-02-15T09:18:30.194Z" title="Updated 2025-02-15 17:18:30">2025-02-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="OS_lab4"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Lab4-上机前复习"><a href="#Lab4-上机前复习" class="headerlink" title="Lab4 上机前复习"></a>Lab4 上机前复习</h1><p>Good luck to you~</p>
<p>太久不上机，之前的技巧不要忘了：</p>
<ul>
<li>grep -r 实现查找</li>
<li>tmux分屏，exit退出分屏</li>
<li>&#x2F;str在vim界面下实现查找</li>
<li>减法压栈，加法弹栈（释放空间）</li>
<li><code>envid2env(u_int envid, struct Env **penv, int checkperm)</code>获得进程控制块，<strong>注意这里的perm一般情况下都是1，checkperm表示是否需要对当前进程的权限进行检查，即当前进程是否有权限操作envid所代表的进程</strong>，如果为0则表示不需要检查。</li>
<li>可以使用<code>vpt[VPN(va)]</code>获得页表项，<code>vpd[va &gt;&gt; 22]</code>获得指向页表项的页目录项</li>
<li>在使用的时候：<code>vpt[页号]</code>就是该页对应的页表项的内容，不再是指针，而页号可以通过<code>addr &gt;&gt; PGSHIFT</code>获得，同样，<code>addr</code>可以通过<code>页号&lt;&lt; PGSHIFT</code>获得，页号还可以通过<code>VPN(va)</code>获得</li>
<li>二级页表的物理地址：<code>vpd[va &gt;&gt; 22] &amp; (~0xfff)</code></li>
<li>页表项指向的物理页面的地址：<code>vpt[va &gt;&gt; 12] &amp; (~0xfff)</code></li>
<li><code>PGSHIFT</code>等于12，<code>PAGE_SIZE</code>是4096</li>
<li>已知页号<code>i</code>可以通过<code>vpt[i]</code>获得页表项，还可以通过<code>vpd[i &gt;&gt; 10]</code>获得页目录项，通常在检查有效位时使用。</li>
<li>通过<code>vpt[vpn] &amp; 0xfff</code>获得perm，该perm包含所有权限位</li>
<li>通过<code>perm &amp; PTE_D</code>判断该位是否为1，同时也可通过该方法取消PTE_D位</li>
<li>通过<code>perm | PTE_COW</code>添加写时复制的标记位。</li>
<li>出现错误后，记住EPC中的值，执行<code>make objdump</code>，然后会生成一些文件，找到<code>mos.objdump</code>文件，使用&#x2F;查找该epc，定位出错的指令。</li>
</ul>
<p>and：上机在一定范围内是可以问的，所以多问！！</p>
<h2 id="梳理函数及其作用"><a href="#梳理函数及其作用" class="headerlink" title="梳理函数及其作用"></a>梳理函数及其作用</h2><p>lab4主要任务如下：</p>
<ul>
<li>掌握系统调用的概念及流程</li>
<li>实现进程间通信机制</li>
<li>实现fork函数</li>
<li>掌握页写入异常的处理流程</li>
</ul>
<h3 id="struct-Trapframe-的结构"><a href="#struct-Trapframe-的结构" class="headerlink" title="struct Trapframe 的结构"></a><code>struct Trapframe</code> 的结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> &#123;</span></span><br><span class="line">        <span class="comment">/* Saved main processor registers. */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> regs[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Saved special registers. */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> cp0_status;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> hi;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> lo;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> cp0_badvaddr;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> cp0_cause;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> cp0_epc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>a0-a3</code>寄存器：4-7</p>
<p><code>t0-t7</code>寄存器：8-15</p>
<p><code>t8-t9</code>寄存器：24-25</p>
<p><code>s0-s7</code>寄存器：16-23</p>
<p><code>k0-k1</code>寄存器：26-27</p>
<p><code>sp</code>寄存器：29</p>
<p><code>ra</code>寄存器：31</p>
<h3 id="struct-Env的结构"><a href="#struct-Env的结构" class="headerlink" title="struct Env的结构"></a><code>struct Env</code>的结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">	u_int env_ipc_value;</span><br><span class="line">	u_int env_ipc_from; <span class="comment">//发送方id</span></span><br><span class="line">	u_int env_ipc_recving; <span class="comment">//是否处于接收状态</span></span><br><span class="line">	u_int env_ipc_dstva; <span class="comment">//接收到的页面需要和 自身的哪个虚拟页面 完成映射</span></span><br><span class="line">	u_int env_ipv_perm; <span class="comment">//传递的页面的权限位置，即当该进程是发送方式时，发送的页面的权限位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用的流程：（所有<code>syscall</code>开头的函数都是用户态函数，所有<code>sys</code>开头的函数都是内核中调用的函数。</p>
<ul>
<li><code>syscall_*</code>函数调用<code>msyscall</code>函数 （用户态），此处注意所有的<code>syscall_*</code>都存放在<code>user/lib/syscall_lib.c</code></li>
<li>异常分发至<code>handle_sys</code>函数，调用<code>do_syscall</code>函数，此时主要将系统调用所需要的信息传递进入内核（内核态）</li>
<li>内核获取信息后，执行对应的内核空间的系统调用函数<code>sys_*</code>（内核态）</li>
<li>系统调用完成后返回用户态，并将返回值传递给用户态（用户态）</li>
<li>从系统调用函数返回，返回至用户最开始的函数（用户态）</li>
</ul>
<p>下面对以上过程进行分析：</p>
<h4 id="用户态传参至内核态的方法"><a href="#用户态传参至内核态的方法" class="headerlink" title="用户态传参至内核态的方法"></a>用户态传参至内核态的方法</h4><ul>
<li><code>msyscall</code>函数：该函数共有6个参数，其中第一个参数是系统调用号（宏定义），其余5个参数是系统调用时需要传递给内核的参数。</li>
</ul>
<p>总的来说，前四个参数被存放在寄存器<code>$a0-$a3</code>中，而剩余的参数仅存放在栈中，栈帧底部保留16个字节的空间，在其之上的8个字节空间存放剩余的参数。</p>
<p>不过<strong>以上步骤无需我们具体实现，编译器会在需要传参的时候将其自动编译为汇编代码</strong></p>
<h4 id="内核态如何获取参数"><a href="#内核态如何获取参数" class="headerlink" title="内核态如何获取参数"></a>内核态如何获取参数</h4><p>在切换到内核态后，内核首先需要将原用户进程的运行现场保存到内核空间（Trapframe），**随后<code>$sp</code>便指向这个保存的<code>Trapframe</code>**，我们只需要传递该结构体的指针即可获得保存在用户态中的参数。</p>
<p>也就是说，<strong>从trapframe里的第29号寄存器中得到的值就是存储参数的起始地址，我们需要对其进行+16&#x2F;+20获得后两个参数</strong></p>
<p>同时<strong>修改trapframe里的2号寄存器</strong>，将其改成函数的返回值。此函数通过<code>sysno</code>系统调用号索引存放函数指针的数组获得。</p>
<h4 id="几个基础的系统调用"><a href="#几个基础的系统调用" class="headerlink" title="几个基础的系统调用"></a>几个基础的系统调用</h4><h5 id="sys-mem-alloc-u-int-envid-u-int-va-u-int-perm"><a href="#sys-mem-alloc-u-int-envid-u-int-va-u-int-perm" class="headerlink" title="sys_mem_alloc(u_int envid, u_int va, u_int perm)"></a><code>sys_mem_alloc(u_int envid, u_int va, u_int perm)</code></h5><p>用户程序通过该系统调用给该程序所允许的虚拟地址空间显式地分配实际的物理内存，进而可以通过虚拟页面对物理内存进行存取访问。</p>
<p>此处填写的<code>envid2env(u_int envid, struct Env **penv, int checkperm)</code>负责根据进程标识符获得进程标识块。</p>
<p>其中调用了:</p>
<ul>
<li><code>envid2env</code>获得进程控制块</li>
<li><code>page_alloc</code>获得物理页面控制块</li>
<li><code>page_insert</code>将获得的物理页面和进程实现映射</li>
</ul>
<p>注意以上函数均被<code>try</code>包围以便返回对应的错误值。</p>
<h5 id="sys-mem-map-u-int-srcid-u-int-srcva-u-int-dstid-u-int-dstva-u-int-perm"><a href="#sys-mem-map-u-int-srcid-u-int-srcva-u-int-dstid-u-int-dstva-u-int-perm" class="headerlink" title="sys_mem_map(u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)"></a><code>sys_mem_map(u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)</code></h5><p>将源进程地址空间中的相应内存映射到目标进程的相应地址空间的相应虚拟内存中去，也就是说，此时二者共享一页物理内存。</p>
<p>其中调用了：</p>
<ul>
<li><code>envid2env</code>获得两个进程控制块</li>
<li><code>page_lookup</code>获得原进程的相应内存</li>
<li><code>page_insert</code>实现映射</li>
</ul>
<p>注意page_lookup并不用try包裹，而是判断返回值是否为空，进而决定是否返回相应的错误值。</p>
<h5 id="sys-mem-unmap-u-int-envid-u-int-va"><a href="#sys-mem-unmap-u-int-envid-u-int-va" class="headerlink" title="sys_mem_unmap(u_int envid, u_int va)"></a><code>sys_mem_unmap(u_int envid, u_int va)</code></h5><p>解除某个进程的虚拟内存和物理内存之间的映射关系。</p>
<p>其中调用了：</p>
<ul>
<li><code>envid2env</code>获得进程控制块</li>
<li><code>page_remove</code>解除页面映射关系</li>
</ul>
<h5 id="sys-yield-void"><a href="#sys-yield-void" class="headerlink" title="sys_yield(void)"></a><code>sys_yield(void)</code></h5><p>实现用户进程对cpu的放弃。</p>
<p>其中调用了:</p>
<ul>
<li><code>schedule</code>函数，将yield参数设置为1</li>
</ul>
<h3 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信&#x2F;IPC"></a>进程间通信&#x2F;IPC</h3><p>IPC需要通过系统调用进行实现。两个进程之间的地址空间独立，因此现在需要考虑如何将一个地址空间中的数据传递给另一个地址空间。</p>
<h5 id="如何将一个地址空间中的数据传递给另一个地址空间"><a href="#如何将一个地址空间中的数据传递给另一个地址空间" class="headerlink" title="如何将一个地址空间中的数据传递给另一个地址空间"></a>如何将一个地址空间中的数据传递给另一个地址空间</h5><p>所有进程共享同一个内核空间，因此借助内核空间实现。</p>
<p>具体来说，发送方将数据<strong>以系统调用的形式存放在进程控制块中</strong>，接收方同样<strong>以系统调用的方式在进程控制块中找到对应的数据</strong></p>
<h5 id="sys-ipc-recv-u-int-dstva"><a href="#sys-ipc-recv-u-int-dstva" class="headerlink" title="sys_ipc_recv(u_int dstva)"></a><code>sys_ipc_recv(u_int dstva)</code></h5><p>该函数主要用于接收消息前的准备工作。</p>
<p>在函数中，设置了进程的标记位、dstva，同时阻塞当前进程，设置状态为NOT_RUNNABLE，再将其<strong>移除env_sched_list</strong>，最后放弃占用CPU</p>
<h5 id="sys-ipc-try-send-u-int-envid-u-int-value-u-int-srcva-u-int-perm"><a href="#sys-ipc-try-send-u-int-envid-u-int-value-u-int-srcva-u-int-perm" class="headerlink" title="sys_ipc_try_send(u_int envid, u_int value, u_int srcva, u_int perm)"></a><code>sys_ipc_try_send(u_int envid, u_int value, u_int srcva, u_int perm)</code></h5><p>该函数用于发送信息。其中的envid表示要向哪个进程发送消息，当该进程为可接收状态时（进程控制块中对应标记位为1），则发送成功。</p>
<p>而发送的具体操作是：通过envid找到接受信息的进程的进程控制块，设置其相关值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">e-&gt;env_ipc_value = value;</span><br><span class="line">e-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">e-&gt;env_ipc_perm = PTE_V | perm;</span><br><span class="line">e-&gt;env_ipc_recving = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>同时将接受信息的进程设置为runnable，并且将其插入schedlist的尾部</p>
<p>注意这个地方的<strong>物理地址映射</strong>——（也就是实现了通过共享地址空间实现信息传递</p>
<p>只有srcva不为0时才会映射！！！srcva为0表示仅传递数值而不需要建立两个进程的页面的映射关系。这个映射关系是指：发送信息进程的srcva对应的物理页面和接收信息进程的env_ipc_dstva建立映射关系，也即二者共享一个物理页面。</p>
<p>具体来说，先用page_lookup找到srcva对应的物理页面，再用page_insert建立该物理页面和env_ipc_dstva的映射关系</p>
<p>且此处获得接收方的进程控制块时，checkperm应为假，因为此处不要求父子关系</p>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>fork是用户进程创建一个新进程的方法，而<code>env_create</code>是内核创建一个新进程的方法。调用fork后原进程<strong>分叉</strong>成为两个进程。</p>
<p>fork是用户态函数。</p>
<p>父子进程间的通信往往更加方便，因为子进程中仍能读取父进程中的部分数据继承了父进程的代码段和数据段等内容），父进程也可以根据子进程的<code>envid</code>控制其行为。</p>
<p>注意一个点：</p>
<ul>
<li>fork后父子进程同时开始执行<strong>fork之后</strong>的代码段，也就是说只有父进程调用了fork，而子进程并没有调用fork。</li>
<li>子进程会继承父进程地址空间中的<strong>代码段和数据段</strong>等内容。也即<strong>程序是相同的</strong>。</li>
</ul>
<h4 id="exec调用"><a href="#exec调用" class="headerlink" title="exec调用"></a>exec调用</h4><p>exec调用会使进程抛弃现有的程序和内存现场，执行一个新的程序。注意：fork创建的仅仅是一个新的进程，进程中当然可以运行新的程序。</p>
<p>fork的一种常见应用被称为<code>fork-exec</code>，指在fork出的子进程中调用exec，从而在创建出的新进程中运行另一个程序。</p>
<h4 id="fork流程图"><a href="#fork流程图" class="headerlink" title="fork流程图"></a>fork流程图</h4><ul>
<li>父进程调用fork函数<ul>
<li>调用<code>syscall_set_tlb_mod_entry</code>设置当前进程的TLB Mod异常处理函数</li>
<li>调用<code>syscall_exofork</code>函数为子进程分配进程控制块</li>
<li>将当前进程低于<code>USTACKTOP</code>的虚拟页标记为写时复制映射到子进程虚拟地址空间（duppage）</li>
<li>调用<code>syscall_set_tlb_mod_entry</code>设置子进程的TLB Mod异常处理函数</li>
<li>调用<code>syscall_set_env_status</code>进程使子进程处于就绪状态，并将子进程加入调度队列<code>env_sched_list</code>中</li>
</ul>
</li>
<li>子进程通过<code>env_run</code>函数启动运行<ul>
<li>最终通过调用<code>ret_from_exception</code>从内核栈的TrapFrame中恢复上下文</li>
<li>子进程从<code>fork</code>函数中的<code>syscall_exofork</code>调用处返回，返回0</li>
<li>子进程设置<code>env</code>变量，从<code>fork</code>中返回，返回值为0</li>
</ul>
</li>
</ul>
<h4 id="写时复制机制"><a href="#写时复制机制" class="headerlink" title="写时复制机制"></a>写时复制机制</h4><p>父子进程对于内存的修改应该互不影响。而为了父子进程能够共用更多的物理内存，仅对要修改的页面进行复制即可。</p>
<p>具体来说，我们将地址空间中的所有可写页标记为写时复制页面。当父进程&#x2F;子进程对写时复制页面进程写入时，会产生一种异常，在异常处理时，我们可以为当前要写入的地址分配新的物理页面，复制原有的内容到新的物理页面，返回用户程序，使其对新的物理页面进行写入。</p>
<p>该异常借助<strong>TLB Mod异常</strong>实现，将写时复制页面的PTE_D位设置为0，当尝试写该页面时即触发TLB Mod异常，同时，为了区分真正的只读页面和写时复制页面，我们增加新的标志位PTE_COW，当处理TLB Mod异常时，若PTE_COW为1，则进行写时复制的处理。</p>
<p>为实现上述机制，fork需要对父进程所有的可写入页面的权限位进行设置，也就是<code>PTE_D</code>位设置为0，<code>PTE_COW</code>位设置为1</p>
<h5 id="syscall-exofork"><a href="#syscall-exofork" class="headerlink" title="syscall_exofork"></a><code>syscall_exofork</code></h5><ul>
<li>父进程是在系统调用结束后恢复现场，而子进程是在被调度的时候恢复现场</li>
<li>返回时都会从内核返回到msyscall函数中，此时二者v0寄存器储存的函数返回值不同，该返回值随后回到<code>syscall_exofork</code>和<code>fork</code>函数中，以区分父子进程。</li>
<li>由于当前子进程为不可运行状态，所以在调用<code>syscall_exofork</code>函数后还可以对子进程做进一步的修改，如设置写时复制等等，又由于子进程的上下文是父进程的复制，所以<strong>子进程一旦开始运行，则同样会从<code>sys_exofork</code>处返回，和父进程一致</strong>。</li>
<li>也就是说，子进程此时的上下文依旧是父进程调用<code>syscall_exofork</code>时的上下文，因此子进程第一次运行时，也会从<code>syscall_exofork</code>之后继续执行<code>fork</code>函数的剩余部分。</li>
</ul>
<p>该函数实现了新进程的建立。</p>
<p>其中调用了：</p>
<ul>
<li><code>env_alloc</code>分配了一个新的进程块，注意父子进程的envid是一样的。</li>
<li>设置了新进程的tf、status、pri，同时还将v0寄存器的返回值设置为0，以确定其为子进程</li>
<li>注意tf的写法！！<code>e-&gt;env_tf = *((struct Trapframe *)KSTACKTOP - 1)</code></li>
</ul>
<h4 id="地址空间准备"><a href="#地址空间准备" class="headerlink" title="地址空间准备"></a>地址空间准备</h4><p>遍历父进程的大部分用户空间页，将需要和子进程共享的页面映射给子进程，同时对于可写入页面的页表项设置权限位。</p>
<p>注意这里给出了vpt和vpd的概念：</p>
<ul>
<li><code>vpt</code>是所有页表的起始地址，<code>vpd</code>是页目录的起始地址</li>
<li>在使用的时候：<code>vpt[页号]</code>就是该页对应的页表项的内容，不再是指针，而页号可以通过<code>addr &gt;&gt; PGSHIFT</code>获得，同样，<code>addr</code>可以通过<code>页号&lt;&lt; PGSHIFT</code>获得，页号还可以通过<code>VPN(va)</code>获得</li>
<li><code>PGSHIFT</code>等于12，<code>PAGE_SIZE</code>是4096</li>
<li>已知页号<code>i</code>可以通过<code>vpt[i]</code>获得页表项，还可以通过<code>vpd[i &gt;&gt; 10]</code>获得页目录项，通常在检查有效位时使用。</li>
</ul>
<p>其他的一些点：</p>
<ul>
<li>通过<code>vpt[vpn] &amp; 0xfff</code>获得perm，该perm包含所有权限位</li>
<li>通过<code>perm &amp; PTE_D</code>判断该位是否为1，同时也可通过该方法取消PTE_D位</li>
<li>通过<code>perm | PTE_COW</code>添加写时复制的标记位。</li>
</ul>
<h5 id="duppage-u-int-envid-u-int-vpn"><a href="#duppage-u-int-envid-u-int-vpn" class="headerlink" title="duppage(u_int envid, u_int vpn)"></a><code>duppage(u_int envid, u_int vpn)</code></h5><p>完成父进程对子进程空间的映射，同时处理权限位。</p>
<h3 id="页写入异常的处理流程"><a href="#页写入异常的处理流程" class="headerlink" title="页写入异常的处理流程"></a>页写入异常的处理流程</h3><p>注意此处<strong>页写入异常的处理主要是在用户态下进行的</strong>。用户进程需要一个单独的栈来执行处理程序，称为异常处理栈，其栈顶对应<code>UXSTACKTOP</code>，同时，内核需要知道这个处理程序的地址，存放在进程的控制块中，由父进程设置。</p>
<ul>
<li>触发写时复制机制，恢复后如同调用了<code>cow_entry</code>函数</li>
<li>当用户完成了<code>cow_entry</code>函数，其会调用<code>syscall_set_trapframe</code>设置上下文为触发TLB Mod时的上下文，也就是<strong>恢复后从触发写时复制的指令处继续执行</strong>。</li>
</ul>
<h4 id="do-tlb-mod"><a href="#do-tlb-mod" class="headerlink" title="do_tlb_mod"></a><code>do_tlb_mod</code></h4><p>该函数负责将当前现场保存在异常处理栈中，并设置a0（4号）和EPC寄存器的值，使得从异常恢复后能够以异常处理栈中保存的现场<code>Trapframe</code>为参数跳转到用户异常处理函数</p>
<h4 id="cow-entry"><a href="#cow-entry" class="headerlink" title="cow_entry"></a><code>cow_entry</code></h4><p>进行写时复制的处理，随后使用系统调用<code>syscall_set_trapframe</code>恢复事先保护好的现场</p>
<p>注意一个小点：</p>
<p>VPN(va)获得该虚拟地址的页号，与vpt搭配使用得到页表项的内容</p>
<h3 id="回到fork函数"><a href="#回到fork函数" class="headerlink" title="回到fork函数"></a>回到fork函数</h3><p>fork函数的流程：</p>
<ul>
<li><code>sys_exofork</code>创建新的进程</li>
<li>遍历父进程地址空间进行<code>duppage</code></li>
<li>设置进程的页写入异常处理函数</li>
<li>设置子进程的env_status确保其可以被调度</li>
<li>返回子进程的env_id</li>
</ul>
<h2 id="来点往年题"><a href="#来点往年题" class="headerlink" title="来点往年题"></a>来点往年题</h2><h3 id="2023-exam-4-1"><a href="#2023-exam-4-1" class="headerlink" title="2023_exam_4-1"></a>2023_exam_4-1</h3><p>组内传播，要求在组传送信息时非同组的进程不可接受信息</p>
<p>较课下实现的send多了一个判断，即：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (e-&gt;env_gid != curenv-&gt;env_gid) &#123; <span class="comment">// 唯一与 ipc_send 不同的地方就在这了</span></span><br><span class="line">  <span class="keyword">return</span> -E_IPC_NOT_GROUP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_try_group_send</span><span class="params">(u_int whom, u_int val, <span class="type">const</span> <span class="type">void</span> *srcva, u_int perm)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">	try(envid2env(whom, &amp;e, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (e-&gt;env_gid != curenv-&gt;env_gid) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_IPC_NOT_GROUP;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	try(sys_ipc_try_send(whom, val, srcva, perm));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ipc_group_send</span><span class="params">(u_int whom, u_int val, <span class="type">const</span> <span class="type">void</span> *srcva, u_int perm)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="comment">// 你需要实现此 syscall_ipc_try_group_send 系统调用</span></span><br><span class="line">    <span class="keyword">while</span> ((r = syscall_ipc_try_group_send(whom, val, srcva, perm)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 接受方进程尚未准备好接受消息，进程切换，后续继续轮询尝试发送请求</span></span><br><span class="line">        <span class="keyword">if</span> (r == -E_IPC_NOT_RECV) syscall_yield();</span><br><span class="line">        <span class="comment">// 接收方进程准备好接收消息，但非同组通信，消息发送失败，停止轮询，返回错误码 -E_IPC_NOT_GROUP</span></span><br><span class="line">        <span class="keyword">if</span> (r == -E_IPC_NOT_GROUP) <span class="keyword">return</span> -E_IPC_NOT_GROUP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数返回0，告知用户成功发送消息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路总结：如何添加一个新的、可用的系统调用"><a href="#思路总结：如何添加一个新的、可用的系统调用" class="headerlink" title="思路总结：如何添加一个新的、可用的系统调用"></a>思路总结：如何添加一个新的、可用的系统调用</h3><p>内核态：</p>
<ul>
<li><p>从内核出发，编写一个能够完成该功能的函数，看一下都需要什么参数 <code>kern/syscall_all.c</code></p>
</li>
<li><p>在<code>void *syscall_table[MAX_SYSNO]</code>中添加该函数，使得<code>do_syscall</code>函数能跳到这个新函数里，注意需要添加系统调用号。<code>kern/syscall_all.c</code></p>
</li>
<li><p>找到新定义的系统调用号的枚举类，把定义加上：<code>include/syscall.h</code></p>
</li>
</ul>
<p>用户态：</p>
<ul>
<li><p>编写<code>syscall_...</code>函数以调用<code>msyscall</code>，同时需要注意函数的第一个参数是刚刚自己定义的那个新的系统调用号。<code>user/lib/syscall_lib.c</code></p>
</li>
<li><p>编写顶层的用户态函数，其中调用<code>syscall_..</code>函数 ，也就是比如现在让你实现一个什么功能</p>
<p><code>void ipc_broadcast(...)</code>，那么你就在这个函数中调用那个syscall就行了。</p>
</li>
<li><p>函数声明：<code>user/include/lib.h</code>，内核态不需要，用户态需要</p>
</li>
</ul>
<h3 id="2023-extra-lab4-1"><a href="#2023-extra-lab4-1" class="headerlink" title="2023_extra_lab4-1"></a>2023_extra_lab4-1</h3><p>给其后代的所有子进程发送信息</p>
<p>注意一个点：srcva双重判断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(Srcva != <span class="number">0</span> &amp;&amp; is_illegal_va((u_int)srcva))&#123;</span><br><span class="line">	retrun -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>具体的实现思路：通过新建一个系统调用实现该功能，那么核心转到内核系统调用的实现：</p>
<ul>
<li>使用遍历找到所有进程块中该进程的直系子进程</li>
<li>使用bfs找到子进程的子进程</li>
</ul>
<p>具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_broadcast</span><span class="params">(u_int val, <span class="type">void</span> *srcva, u_int perm)</span> &#123;</span><br><span class="line">  u_int childs[<span class="number">20</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    childs[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// printk(&quot;childs ready!\n&quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (srcva != <span class="number">0</span> &amp;&amp; is_illegal_va((u_int)srcva)) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Step1: 找到直系的子进程 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NENV; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (envs[i].env_parent_id == curenv-&gt;env_id) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (childs[j] == <span class="number">0</span>) &#123;</span><br><span class="line">          childs[j] = envs[i].env_id;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step2: 通过 bfs 找到所有子进程的子进程 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; childs[i] != <span class="number">0</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; NENV; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (envs[j].env_parent_id == childs[i]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">20</span>; k++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (childs[k] == envs[j].env_id) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (childs[k] == <span class="number">0</span>) &#123;</span><br><span class="line">            childs[k] = envs[j].env_id;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Step3: 对所有待发送的进程进行发送 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; childs[i] != <span class="number">0</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// printk(&quot;%d: %x\n&quot;, i, childs[i]);</span></span><br><span class="line">      sys_ipc_try_send(childs[i], val, srcva, perm);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2022-exam-lab4-1"><a href="#2022-exam-lab4-1" class="headerlink" title="2022_exam_lab4-1"></a>2022_exam_lab4-1</h3><p>内核面向所有进程维护一个公用的锁，对于用户程序，锁在同一时刻要么被唯一一个进程持有，要么不被任何进程持有，也即锁处于空闲状态</p>
<p>要求实现以下两个用户函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">syscall_try_acquire_console</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//检查并设置锁</span></span><br><span class="line"><span class="comment">//若锁空闲，则设置锁被当前进程持有，且返回0，否则返回-1</span></span><br><span class="line"><span class="comment">//只要锁不处于空闲状态就返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_release_console</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//释放锁</span></span><br><span class="line"><span class="comment">//若锁由当前进程持有，该函数设置锁为空闲状态，且返回0，当前进程不再持有锁，否则返回-1</span></span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ul>
<li>在内核中新增全局变量lock，为0表示空闲，否则为占有它的进程的进程id （在<code>syscall_all.c</code>中加入便于调用）</li>
</ul>
<h3 id="2022-exam-lab4-2"><a href="#2022-exam-lab4-2" class="headerlink" title="2022_exam_lab4_2"></a>2022_exam_lab4_2</h3><ul>
<li><p>如何表示当前进程的页表中不存在该虚拟页：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(vpd[va &gt;&gt; <span class="number">22</span>] &amp; PTE_V) || !(vpt[va &gt;&gt; <span class="number">12</span>] &amp; PTE_V))&#123;</span><br><span class="line">	<span class="comment">//若该条件成立则说明当前进程的页表中不存在该虚拟页</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进而如果想要表示当前进程的页表中存在该虚拟页：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((vpd[va &gt;&gt; <span class="number">22</span>] &amp; PTE_V) &amp;&amp; (vpt[va &gt;&gt; <span class="number">12</span>] &amp; PTE_V))&#123;</span><br><span class="line">	<span class="comment">//若该条件成立则说明当前进程的页表中存在该虚拟页</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何表示若不能分配新的物理页则返回-1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u_int perm = PTE_D | PTE_V; <span class="comment">//注意这里perm的表示</span></span><br><span class="line"><span class="keyword">if</span>(syscall_mem_alloc(<span class="number">0</span>, ROUNDDOWN(va, PAGE_SIZE), perm) != <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何获得va的perm</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">perm = vpt[VPN(va)] &amp; <span class="number">0xfff</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何表示va不在用户空间中：即大于等于UTOP</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(va &gt; (<span class="type">void</span> *)UTOP)</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何表示当前进程的页表中已存在该虚拟页但对进程没有写入权限：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((vpd[va &gt;&gt; <span class="number">22</span>] &amp; PTE_V) &amp;&amp; (vpt[va &gt;&gt; <span class="number">12</span>] &amp; PTE_V) &amp;&amp; !(perm &amp; PTE_D))</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果前面对虚拟地址va有对齐操作，那么后续<code>syscall_mem_map</code>的虚拟地址应当使用：<code>VPN(va) * PAGE_SIZE</code></p>
</li>
<li><p>此题的完整程序代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">make_shared</span><span class="params">(<span class="type">void</span> *va)</span> &#123;</span><br><span class="line">    u_int perm = PTE_D | PTE_V;</span><br><span class="line">    <span class="keyword">if</span> (!(vpd[va &gt;&gt; <span class="number">22</span>] &amp; PTE_V) || !(vpt[va &gt;&gt; <span class="number">12</span>] &amp; PTE_V)) &#123; </span><br><span class="line">        <span class="comment">//当前进程的页表中不存在该虚拟页</span></span><br><span class="line">        <span class="keyword">if</span> (syscall_mem_alloc(<span class="number">0</span>, ROUNDDOWN(va, BY2PG), perm) != <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="comment">//将envid设为0，表示默认curenv</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125; </span><br><span class="line">    perm = vpt[VPN(va)] &amp; <span class="number">0xfff</span>; <span class="comment">//获得va的perm</span></span><br><span class="line">    <span class="keyword">if</span> (va &gt;= (<span class="type">void</span> *)UTOP || </span><br><span class="line">        ((vpd[va &gt;&gt; <span class="number">22</span>] &amp; PTE_V) &amp;&amp; (vpt[va &gt;&gt; <span class="number">12</span>] &amp; PTE_V) &amp;&amp; !(perm &amp; PTE_D))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    perm = perm | PTE_LIBRARY;</span><br><span class="line">    u_int addr = VPN(va) * BY2PG; </span><br><span class="line">    <span class="keyword">if</span> (syscall_mem_map(<span class="number">0</span>, (<span class="type">void</span> *)addr, <span class="number">0</span>, (<span class="type">void</span> *)addr, perm) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="keyword">return</span> ROUNDDOWN(vpt[VPN(va)] &amp; (~<span class="number">0xfff</span>), BY2PG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://lluckkk.github.io">LLUckkk</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://lluckkk.github.io/2025/02/15/OS-lab4/">https://lluckkk.github.io/2025/02/15/OS-lab4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/02/15/OS-lab5/" title="OS_lab5"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">OS_lab5</div></div></a></div><div class="next-post pull-right"><a href="/2025/02/15/OS-lab3/" title="OS_lab3"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">OS_lab3</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2025/02/15/OS-lab3/" title="OS_lab3"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-15</div><div class="title">OS_lab3</div></div></a></div><div><a href="/2025/02/15/OS-lab5/" title="OS_lab5"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-15</div><div class="title">OS_lab5</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">LLUckkk</div><div class="author-info__description">Blogs</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/LLUckkk"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">It's a newsound track I can dance to this beat~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab4-%E4%B8%8A%E6%9C%BA%E5%89%8D%E5%A4%8D%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">Lab4 上机前复习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A2%B3%E7%90%86%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">梳理函数及其作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-Trapframe-%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">struct Trapframe 的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-Env%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">struct Env的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E4%BC%A0%E5%8F%82%E8%87%B3%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">用户态传参至内核态的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%80%81%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">内核态如何获取参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E5%9F%BA%E7%A1%80%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">几个基础的系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#sys-mem-alloc-u-int-envid-u-int-va-u-int-perm"><span class="toc-number">1.1.3.3.1.</span> <span class="toc-text">sys_mem_alloc(u_int envid, u_int va, u_int perm)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sys-mem-map-u-int-srcid-u-int-srcva-u-int-dstid-u-int-dstva-u-int-perm"><span class="toc-number">1.1.3.3.2.</span> <span class="toc-text">sys_mem_map(u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sys-mem-unmap-u-int-envid-u-int-va"><span class="toc-number">1.1.3.3.3.</span> <span class="toc-text">sys_mem_unmap(u_int envid, u_int va)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sys-yield-void"><span class="toc-number">1.1.3.3.4.</span> <span class="toc-text">sys_yield(void)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-IPC"><span class="toc-number">1.1.4.</span> <span class="toc-text">进程间通信&#x2F;IPC</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%80%E4%B8%AA%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E7%BB%99%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.1.4.0.1.</span> <span class="toc-text">如何将一个地址空间中的数据传递给另一个地址空间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sys-ipc-recv-u-int-dstva"><span class="toc-number">1.1.4.0.2.</span> <span class="toc-text">sys_ipc_recv(u_int dstva)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sys-ipc-try-send-u-int-envid-u-int-value-u-int-srcva-u-int-perm"><span class="toc-number">1.1.4.0.3.</span> <span class="toc-text">sys_ipc_try_send(u_int envid, u_int value, u_int srcva, u_int perm)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fork"><span class="toc-number">1.1.5.</span> <span class="toc-text">fork</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#exec%E8%B0%83%E7%94%A8"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">exec调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fork%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">fork流程图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">写时复制机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#syscall-exofork"><span class="toc-number">1.1.5.3.1.</span> <span class="toc-text">syscall_exofork</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%87%86%E5%A4%87"><span class="toc-number">1.1.5.4.</span> <span class="toc-text">地址空间准备</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#duppage-u-int-envid-u-int-vpn"><span class="toc-number">1.1.5.4.1.</span> <span class="toc-text">duppage(u_int envid, u_int vpn)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E5%86%99%E5%85%A5%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.6.</span> <span class="toc-text">页写入异常的处理流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#do-tlb-mod"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">do_tlb_mod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cow-entry"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">cow_entry</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E5%88%B0fork%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.7.</span> <span class="toc-text">回到fork函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A5%E7%82%B9%E5%BE%80%E5%B9%B4%E9%A2%98"><span class="toc-number">1.2.</span> <span class="toc-text">来点往年题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2023-exam-4-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">2023_exam_4-1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%EF%BC%9A%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E3%80%81%E5%8F%AF%E7%94%A8%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">思路总结：如何添加一个新的、可用的系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2023-extra-lab4-1"><span class="toc-number">1.2.3.</span> <span class="toc-text">2023_extra_lab4-1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2022-exam-lab4-1"><span class="toc-number">1.2.4.</span> <span class="toc-text">2022_exam_lab4-1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2022-exam-lab4-2"><span class="toc-number">1.2.5.</span> <span class="toc-text">2022_exam_lab4_2</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/30/PKU-%E4%B8%8A%E6%9C%BA%E8%80%83%E8%AF%95/" title="PKU_上机考试">PKU_上机考试</a><time datetime="2025-06-30T14:03:41.000Z" title="Created 2025-06-30 22:03:41">2025-06-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/29/C/" title="C++">C++</a><time datetime="2025-06-29T12:20:27.000Z" title="Created 2025-06-29 20:20:27">2025-06-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/14/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/" title="代码生成——基础知识准备">代码生成——基础知识准备</a><time datetime="2025-06-14T11:30:10.000Z" title="Created 2025-06-14 19:30:10">2025-06-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/14/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E2%80%94%E2%80%94Models/" title="代码生成——Models">代码生成——Models</a><time datetime="2025-06-14T11:23:53.000Z" title="Created 2025-06-14 19:23:53">2025-06-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/14/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E2%80%94%E2%80%94%E7%BB%BC%E8%BF%B0/" title="代码生成——综述">代码生成——综述</a><time datetime="2025-06-14T11:21:49.000Z" title="Created 2025-06-14 19:21:49">2025-06-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By LLUckkk</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">怠惰必将导致惨剧。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.14.0-b3"></script><script src="/js/main.js?v=4.14.0-b3"></script><script src="/js/tw_cn.js?v=4.14.0-b3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.35/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = (ele) => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from(ele).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return
    
    codeMermaidEle.forEach(ele => {
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.innerHTML = `<pre class="mermaid-src" hidden>${ele.textContent}</pre>`
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js').then(runMermaidFn)
  }
  
  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="true" data-text="wutong,hanwen" data-fontsize="20px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>